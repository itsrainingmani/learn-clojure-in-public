# Clojure Fam - Week 1 - Day 5

```clojure
(defmacro did-nothing
	[x]
	(do (prn "This does nothing") nil))
```

## Expectations

Today was a tough day for Clojure learning. There were quite a few personal things that came up precluding me from spending my usual amount of time on dedicated learning. Despite this, I still wanted to give Chapter 5 a shot and see how much I could complete.

## What I learned

Chapter 5 deals with a few different things - macros, recursion and control flow. Control Flow was a topic I'd been looking forward to since just using `if` to structure my programs was quite awkward.

- `cond` is basically a condensed `if` - `else if` - `else` block
- `case` is an expression matching construct. It doesn't seem to allow any complex pattern matching but there's probably different macros to achieve that.
- `if-let` and `when-let` allow you to bind the value of the predicate to a variable that can be re-used in the body. I have a feeling I'm going to end up using these ones a lot due to how convenient they are.
- `recur` can be used without a `loop` construct inside any plain old function. It just implicitly rebinds the function arguments while recursing.
- `lazy-seq`  is a wonderful convenience macro for generating infinitely recursive sequences. The macro interrupts the recursion and rejiggers it into a sequences that are available on demand.

One cool thing that was very briefly mentioned were the `delay` and `defer` macros that allow you to construct more on-demand computation functions.

The chapter finally ends with something that's intimately familiar to every Python programmer - List Comprehensions. This was arguably the easiest concept to learn in Clojure since I'm already well-versed in using list comprehensions. However, unlike Python, Clojure's list comprehensions yield lazy sequences making them quite efficient and allowing them to be chained with other lazy sequence functions like `take` , `filter`  etc.

## 4Clojure and Pair Programming

I only solved one 4Clojure problem today but I did engage in something else that was quite fruitful - A pair programming with fellow Team Seneca member @nthd3gr33. The purpose of the session was to solve 4Clojure problem No 83 together and see what solutions we came up with and how we approached the problem. This session yielded positive results since we were able to solve the problem in multiple ways by collaborating together.

That's all it's going to be for today. The weekend is here and it's time for some R&R and gentle introspection on this last week which has been quite the experience. I believe I will be writing a more in-depth post reflecting on everything I learned over the week and on the processes and workflows that I ended up using.

```clojure
(did-nothing :today)
```

You can also find this post on [Notion](https://www.notion.so/itsrainingmani/Clojure-Fam-Week-1-Day-5-b6d9202aadc740ea828ede4ebaeee3c5).